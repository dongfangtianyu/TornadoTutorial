# 常见的IO模型

1. 同步阻塞IO（Blocking IO）

   * 传统的IO模型
   * 举个例子：

     等水烧开，然后煮面。  
     水烧开前一直在守在灶台前等

   * 特点：

     * 一个任务完成前，不能进行其他的任务

2. 同步非阻塞IO（Non-blocking IO）

   * 在阻塞的基础上，运行线程提前返回
   * 举个例子：

     水烧开前可以去守着孩子，如果孩子踢被子可以帮他盖上，但是需要时常的回来到灶台见检查一下水是否烧开，以便煮面

   * 特点：

     * 一个任务完成前，可以进行其他的任务，但是如果任务多了会疲于奔命（代码复杂）

3. IO多路复用（IO Multiplexing）

   * 通过记录见跟踪每个IO的状态，同时管理多个IO
   * 也有人称为异步阻塞
   * 举个例子：

     每个任务都交给智能助手进行监控，自己的在书房办公，如果哪个任务的有进展及时报告  
     当水烧开了去煮面，  
     当孩子踢被子了去盖被子  
     当快递来了去收快递

   * 特点:

     * 成本高，少量任务不值得，大量任务才能体现价值

4. 异步

   * 不仅是监控状态，状况发生后，操作系统开启独立的内核线程执行下一步操作

   * 举个例子：

     将智能助手升级成智能机器人，教会它煮面、盖被子、收快递，并把任务安排给它。
     当水烧开了【智能机器人】去煮面，
     当孩子踢被子了【智能机器人】去盖被子
     当快递来了【智能机器人】去收快递

   * 特点：

     需要系统的支持。安排好任务之后可以做其他事情去了，可以从容应对大量任务。
     不知道任务什么时候执行（因为当状态发生变化后，由系统调用设定好的步骤，不是通知用户，让用户来执行），是真正的异步


## 一些概念

6. 同步和异步：
  
    - 同步：我亲自做事，所以知道每件事的每个时候是什么状态
    - 异步：委托内核（或者其他线程）做事，所以不知道某个时候的状态，按照约定，当某个状态发生了（比如任务完成），再告诉我

5. 阻塞和非阻塞:

    当一个任务在进行的过程当中，如果只能等待这个任务的结束，而不能进行其他任务的话，就是阻塞的，反之，就是非阻塞。
    虽然在方案的选择上有阻塞和非阻塞，但是实际情况来说，没有从头到尾百分之百的非阻塞。
    举个例子：
      把10个耗时的任务安排给10个助手去做，这是异步的方式，在助手处理这些耗时的任务过程中，我是可以做其他事情的。
      但是当这些助手完成回来报告的时候，我不能同时听清10个人的话，只能一个一个的听，这个阶段还是阻塞的。
      
    在系统中，内核层的数据读写可以是异步的，当内核异步完成，和用户交互的时候，用户层的数据读写还是阻塞的
    
7. 并发和并行：
    - 不并发也不并行： 一个人吃10个馒头，吃完一个再吃下一个
    - 并发： 一个人吃10个馒头，每个馒头都咬一口，全部咬过后，再从第一个开始直到全部都吃完 （交替做不同事）
    - 并行： 十个人吃10个馒头，每人各自咬一个馒头 （同时做不同事）
    - 区别：一段之间后，几个馒头被咬了；某个瞬间，有几个人在咬馒头；
    
## 执行代码看看

```python



```



## 扩展阅读
[高性能IO模型浅析](http://www.cnblogs.com/fanzhidongyzby/p/4098546.html)

