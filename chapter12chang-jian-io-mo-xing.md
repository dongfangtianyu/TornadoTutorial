# 常见的IO模型

1. 同步阻塞IO（Blocking IO）

   * 传统的IO模型
   * 举个例子：

     等水烧开，然后煮面。  
     水烧开前一直在守在灶台前等

   * 特点：

     * 一个任务完成前，不能进行其他的任务

2. 同步非阻塞IO（Non-blocking IO）

   * 在阻塞的基础上，运行线程提前返回
   * 举个例子：

     水烧开前可以去守着孩子，如果孩子踢被子可以帮他盖上，但是需要时常的回来到灶台见检查一下水是否烧开，以便煮面

   * 特点：

     * 一个任务完成前，可以进行其他的任务，但是如果任务多了会疲于奔命（代码复杂）

3. IO多路复用（IO Multiplexing）

   * 通过记录见跟踪每个IO的状态，同时管理多个IO
   * 也有人称为异步阻塞
   * 举个例子：

     每个任务都交给智能助手进行监控，自己的在书房办公，如果哪个任务的有进展及时报告  
     当水烧开了去煮面，  
     当孩子踢被子了去盖被子  
     当快递来了去收快递

   * 特点:

     * 成本高，少量任务不值得，大量任务才能体现价值

4. 异步

   * 不仅是监控状态，状况发生后，操作系统开启独立的内核线程执行下一步操作

   * 举个例子：

     将智能助手升级成智能机器人，教会它煮面、盖被子、收快递，并把任务安排给它。
     当水烧开了【智能机器人】去煮面，
     当孩子踢被子了【智能机器人】去盖被子
     当快递来了【智能机器人】去收快递

   * 特点：

     需要系统的支持，安排好任务之后可以做其他事情去了。不知道任务什么时候执行（因为当状态发生变化后，由系统调用设定好的步骤），是真正的异步

5. 


